===================
Conda-build recipes
===================

.. contents::
   :local:
   :depth: 2

To enable building `conda packages <https://conda.io/projects/conda/en/latest/user-guide/concepts/packages.html>`_, :ref:`install and update conda
and conda-build <install-conda-build>`.

Building a conda package requires a recipe. Enable building
`conda packages <https://conda.io/projects/conda/en/latest/user-guide/concepts/packages.html>`_, :ref:`install and update conda
and conda-build <install-conda-build>`. A conda-build recipe
is a flat directory that contains the following files:

* ``meta.yaml``---A file that contains all the metadata in the
  recipe. Only ``package/name`` and ``package/version`` are
  required.

* ``build.sh``---The script that installs the files for the
  package on macOS and Linux. It is executed using the ``bash``
  command.

* ``bld.bat``---The build script that installs the files for the
  package on Windows. It is executed using ``cmd``.

* ``run_test.[py,pl,sh,bat]``---An optional Python test file, a
  test script that runs automatically if it is part of the recipe.

* Optional patches that are applied to the source.

* Other resources that are not included in the source and cannot
  be generated by the build scripts. Examples are icon files,
  readme files and build notes.

.. tip::
  When you use the `conda skeleton <skeleton_ref>` command,
  the first 3 files---``meta.yaml``, ``build.sh``, and
  ``bld.bat``---are automatically generated for you.

Conda-build process
===================

``conda-build`` performs the following steps:

#. Reads the metadata.

#. Downloads the source into a cache.

#. Extracts the source into the source directory.

#. Applies any patches.

#. Re-evaluates the metadata, if source is necessary to fill any
   metadata values.

#. Creates a build environment and then installs the build
   dependencies there.

#. Runs the build script. The current working directory is the
   source directory with environment variables set. The build
   script installs into the build environment.

#. Performs some necessary post-processing steps, such as shebang
   and rpath.

#. Creates a conda package containing all the files in the build
   environment that are new from step 5, along with the necessary
   conda package metadata.

#. Tests the new conda package if the recipe includes tests:

   #. Deletes the build environment.

   #. Creates a test environment with the package and its
      dependencies.

   #. Runs the test scripts.

The `conda-recipes
<https://github.com/continuumio/conda-recipes>`_ repo
contains example recipes for many conda packages.

.. caution::
   All recipe files, including ``meta.yaml`` and build
   scripts, are included in the final package archive that is
   distributed to users. Be careful not to put sensitive information
   such as passwords into recipes where it could be made public.

The `conda skeleton <skeleton_ref>` command can help to make
skeleton recipes for common repositories, such as `PyPI
<https://pypi.python.org/pypi>`_.


Deep dive
=========

Let's take a closer look at how conda-build uses a recipe
to create a package.
 
Templates
---------

When you build a conda package, conda-build renders the package
by reading a template in the meta.yaml. See :ref:`jinja-templates`.

Templates are filled in using your conda-build config,
which shows the matrix of things to build against. The
``conda build config`` determines how many builds it has to do.
For example, defining a conda_build_config.yaml of the form
and filling it defines a matrix of 4 packages to build::

   foo:
     - 1.0
     - 2.0
   bar:
     - 1.2.0
     - 1.4.0

After this, conda-build determines what the outputs will be.
For example, if your ``conda build config`` indicates that you
want two different versions of Python, conda-build will show
you the rendering for each Python version.

Environments
------------

To build the package, conda-build will make an environment for you
and install all of the build and run dependencies in that environment.
Conda-build will indicate where you can successfully build the package.
The prefix will take the form::

  <path to conda>/conda-bld/<package name and string>/h_env_placeholder…

`Conda-forge <https://anaconda.org/conda-forge>`_ downloads your package source and then builds the conda
package in the context of the build environment. For example, you may
direct it to download from a Git repo or pull down a tarball from
another source. See the :ref:`source-section` for more information.

What conda-build puts into a package depends on what you put into
the build, host, or run sections. See the :ref:`requirements`
for more information.
Conda-build will use this information to identify dependencies to
link to and identify the run requirements for the package. This allows
conda-build to understand what is needed to install the package.


Source/no_hoist
---------------

When conda-build unpacks a source archive, if checks to see
if that archive contains a single folder in its top-level
directory structure. If so, as a convenience to recipe scripts,
this top-level folder is discarded and its contents are hoisted
into the top-level unpack folder. Technically this is destructive
of information (the top-level folder name), which can cause problems,
particularly when repackaging other projects. In the case of
``conda skeleton rpm``, some packages suffered hoisting (e.g. single-level /lib64 folder) while others did not (a /lib64 and a /share
folder), making them mutually incompatible.

.. code-block:: python

   # Hoisting is destructive of information, in CDT packages, a single top level
   # folder of /usr64 must not be discarded.
   if len(flist) == 1 and os.path.isdir(folder) and 'no_hoist' not in source_dict:
       hoist_single_extracted_folder(folder)

You can specify ``source/no_hoist`` and conda-build will not perform this
check, unpacking this source entry literally.

Building
--------

Once the content is downloaded, conda-build runs the build step.
See the :ref:`meta-build` for more information.
The build step runs a script. It can be one that you provided. 
See the :ref:`build-script` section for more information. 

If you do not define the script section, then you can create a
build.sh or a bld.bat file to be run.


Prefix replacement
------------------

When the build environment is created, it is in a placeholder prefix.
When the package is all bundled up, the prefix is set to a dummy prefix.
When conda is ready to install the package, it rewrites the dummy
prefix with the correct one.


Regex replacement
-----------------

We often need to, after building a recipe but prior to packaging it,
replace some strings in some generated files. On Linux and macOS,
we often find the build prefix or the sysroot getting baked into
files, which causes problems because those folders are temporary.

Instead, in general, we want to replace those baked-in files with a
token or environment variable.

You can add keys to your conda_build_config.yaml called ``replacements/all_replacements``.
This is a list of replacement instructions for conda-build to perform during its post-build
phase. For example:

.. code-block::
   
   replacements:
   all_replacements:
     - tag: 'pkg-config build metadata'
       glob_patterns:
         - '*.pc'
       regex_re: '(?:-L|-I)?\"?([^;\s]+\/sysroot\/)'
       replacement_re: '$(CONDA_BUILD_SYSROOT_S)'
       regex_rg: '([^;\s"]+/sysroot/)'
     - tag: 'CMake build metadata'
       glob_patterns:
         - '*.cmake'
       regex_re: '([^;\s"]+/sysroot)'
       replacement_re: '$ENV{CONDA_BUILD_SYSROOT}'
     - tag: 'qmake build metadata'
       glob_patterns:
         - '*.pri'
         - '*.prl'
       regex_re: '(?:-L|-I)?\"?([^;\s]+\/sysroot)'
       replacement_re: '$(CONDA_BUILD_SYSROOT)'
       regex_rg: '([^;\s"]+/sysroot)'

* ``regex_re`` is in ``PCRE2`` format and is strictly as tight or
  tighter matching that ``regex_rg (rg==ripgrep)``. ``regex_rg`` is
  optional. If only ``regex_re`` is provided then it must be compatible
  with both ``PCRE2`` and ``ripgrep`` regex formats. If your regex is
  not compatible with both, then you must design a simpler, possibly
  looser one for ``regex_rg``.

* ``tag`` is informational. Conda-build will print this out.

* ``replacement_re`` is a ``PRCE2`` regex and can contain references
  to groups mentioned in ``regex_re`` to allow more complex substitutions.

* ``glob_patterns`` is a list of glob wildcards to consider for this
  prefix replacement.

Testing
-------

Once a package is built, conda-build will test it. To do this, it
creates another environment and installs the conda package. The form
of this prefix is::

  <path to conda>/conda-bld/<package name + string>/_test_env_placeholder…

At this point, conda-build has all of the info from the meta.yaml about
what its runtime dependencies are, so those dependencies are installed
as well. This generates a test runner script with a reference to the
testing meta.yaml that is created. See the :ref:`meta-test` for 
more information. That file is run for testing.

Output metadata
---------------

After the package is built and tested, conda-build cleans up the
environments created prior and outputs the metadata. The recipe for
the package is also added in the output metadata. The metadata directory
is on the top level of the tarball in the ``info`` directory.
The metadata contains information about the dependencies of the
package and a list of where all of the files in the package go when
it is installed. Conda reads that metadata when it needs to install.

Running ``conda install`` causes conda to:

  * reach out to the repo data containing the dependencies,
  * guess the right dependencies,
  * install a list of packages,
  * unpack the tarball to look at the info,
  * verify the file based on metadata in the package, and then
  * go through each file in the package and puts it in the right location.


More information
================

Review :doc:`../resources/define-metadata` to see a breakdown of the
components of a recipe, including:

  * package name
  * package version
  * descriptive metadata
  * where to obtain source code
  * how to test the package
